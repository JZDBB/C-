# 树

融合静态和动态操作。

## 概念

定义在一组元素的二元关系——特殊的图$T=(V, E)$，结点数$|V|=n$，边数$|E|=e$。

- 有根树：指定任一结点$r \in V$作为根后，$T$为有根树，嵌套$T_i$的根节点，通过新结点加对应邻边组成更大的有根树，相对于$T$，$T_i$成为以$r_i$为更的子树，$T_i = subtree(r_i)$
- 有序树：具有一定次序的树。$r_i$为$r$的子，$d=degree(r)$ 为$r$的度。归纳得$e=\sum_{r \in V}degree(r)=n-1=\Theta(n)$，用$n$以衡量复杂度。
- 路径：
  - $V$中$k+1$个节点，通过$E$中的$k$条边依次相连，构成一条路径，路径长度：$k$=为边数。
  - 特殊路径：环路$k_0=k_v$
- 连通：
  - 各节点之间均有路径，称作连通图。
  - 不含环路，称作无环图。
- 树：
  - 无环连通图、极小连通图、极大无环图。
  - 任一结点与根之间只存在唯一路径。树只能指定一个根。
- 深度：
  - 路径、结点、子树可相互指代：$path(v) \sim v \sim subtree(v)$
  - $v$的深度：$depth(v)=|path(v)|$
  - $path$上节点均为$v$的祖先，$v$是他们的后代。
  - 根节点是所有节点的公共祖先，深度为0。
  - 没有后代的节点为叶节点。叶子中深度最大的称作树的高度。特别的，空树的高度为$-1$。
  - $depth(v)+height(v) \le height(T)$ ：等号何时取？

![image-20200306135555709](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-概念.png)



## 树结构

接口包括：`root, parent, firstchild, nextSibling,insert, remove, traverse`。

- 父节点：任何一个节点有且仅有一个父节点。

  ![image-20200306142930670](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-父子节点查找.png)

- 对于父节点有：`firstchild`，对于子节点有`nextSibling`。

  ![image-20200306144459530](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-长子兄弟.png)



## 二叉树

节点度数不超过2的树。对于子树可以称为左子树和右子树。

- 深度为$k$的节点，最多$2^k$个。含$n$个节点、高度为$h$的二叉树，$h<n<2^{h+1}$。$n=h+1$时，为单链。$n=2^{h+1}-1$ 为满二叉树。满树高度增长慢，宽度增长快。

#### 二叉树描述多叉树

二叉树**有根**且**有序**时可以描述多叉树。采用长子兄弟结构。

### 二叉树实现

#### 树结构

![image-20200306144924898](C:\Users\yn\Desktop\C++\NOTES\DSA\img\二叉树实现.png)

其他函数



### 二叉树遍历

二叉树为半线性结构。

遍历规则：按照某种次序遍历各节点一次。分为先序($V|L|R$)，中序($L|V|R$)和后序($L|R|V$)。层次遍历（自上而下，先左后右）

#### 先序

递归遍历：

![image-20200306151203706](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-先序遍历-递归.png)

递归改为迭代：

![image-20200306151538365](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-先序遍历-迭代1.png)

![image-20200306152738201](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-先序遍历-迭代2.png)

![image-20200306152802968](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-先序遍历-迭代3.png)





#### 中序遍历

`VST & visit`

![image-20200306154515273](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-中序遍历-迭代.png)

##### 开销的分摊计算

两个迭代循环，最终是否满足$o(n)$ 是开销？取决于以下条件：

- 每次迭代都恰有一个节点出栈进行访问

- 每个节点只入栈一次

- 每次迭代只需要$o(1)$的时间

  单次调用`goAloneVine()`可能需要$\Omega(n)$ ，事实上的开销需要分摊计算。

#### 后序遍历

![image-20200306170945820](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-后序遍历-迭代.png)

![image-20200306171208802](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-后序遍历-迭代2.png)

##### 后序遍历应用——表达式树

![image-20200306171444676](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-后序表达式树.png)



#### 层次遍历

严格按照深度进行遍历——借助队列。

![image-20200306171538931](C:\Users\yn\Desktop\C++\NOTES\DSA\img\树-层次遍历.png)



#### 树重构——[先序|后序]+中序

中序遍历能够区分左右子树，所以必不可少，不然容易歧义。

但是真二叉树可以通过先序+后序进行还原，真二叉树的子节点只能有偶数个。



#### 完全二叉树

叶节点仅限于最低两层，除开末节点的父亲，内部节点均有左右节点。

**叶节点不少于内部节点，但是最多多出一个。**