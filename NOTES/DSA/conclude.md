## 常见算法开销
折半的算法：（二分查找）：$T(n)=T(n/2)+\mathcal{O}(1)=\mathcal{O}(logn)$ 

归并排序：$T(n)=2T(n/2)+o(n)=o(nlogn)$。





## 排序算法归纳

### 向量排序

#### 冒泡排序

- 问题:给定n个可比较的元素，将它们按(非降)序排列

  - **观察:**有序/无序序列中,任何/总有一对相邻元素顺序/逆序

  - **扫描交换**:依次比较每一对相邻元素;如有必要,交换之

  - 若整趟扫描都没有进行交换,则排序完成;否则,再做一趟扫描交换 

  - 提前终止版

    <img src=".\img\冒泡排序-code.png" width=600px>

  - 跳跃版

    <img src=".\img\冒泡排序-code2.png" width=600px>

  - **综合评价：**

    - 最好情况为$0(n)$， 最差为$o(n^2)$

    - 稳定的：因为在重复数组输入输出的相对次序是保持不变的——有赖于 `if` 判断后的交换语句中为 `>` 而不是 `>=`

      <img src=".\img\排序算法-稳定性.png" width=400px>


#### 归并排序

 - 分治策略：划分子序列 $o(1)$，子序列递归排序 $2 \times T(n/2)$，子序列合并$o(n)$

  - 最终复杂度$T(n)=2T(n/2)+o(n)=o(nlogn)$。

  - 子序列合并中消耗为两个子序列长度成线性关系。

    <img src=".\img\归并排序-子序列合并.png" width=600px>

  - 优点：算法性能好，具有稳定性，可扩展性好，易于并行。

  - 缺点：需要对等规模的存储空间，在输入接近有序的时候开销依然是$o(nlogn)$

##### 插值查找（扩）

### 列表排序

#### 选择排序（效率较高的冒泡排序）

<img src=".\img\选择排序.png" width=600px>

<img src=".\img\列表找最大值.png" width=600px>

##### 性能分析：

- `sellectMax()` 开销为$o(n-k)$
- `remove()` 和 `insertBefor()` 开销均为$o(1)$
- 总开销：$\Theta(n^2)$，无论最好最坏开销相同。
- 优势在于，减少了在实际中的**移动操作**。主要开销来自于比较操作。这是比向量较好的。

#### 插入排序

<img src=".\img\插入排序-code.png" width=600px>

##### **性能分析：**

- 最好的情况为只需要插在队尾开销为$o(n)$，最差的情况为$o(n^2)$
- 二分查找由于需要循秩一般用于向量，如果采用二分查找进行插入就需要用向量，但是对于向量而言，插入排序需要将后面的元素依次后移，得不偿失。
  - 原先需要$o(k)$次比较，1次交换
  - 改为向量为$o(logn)$ 次查找，$o(n)$的开销用于插入
- 平均性能：
  - 假设元素 $r$ 插入列表中，其中$r+1$元素都可能是刚刚插入的 $r$ 元素，等概率$1/(r+1)$
  - 则完成这次迭代的开销的数学期望 $S(r)=[r+(r-1)+...+1+0]/(r+1)+1=r/2+1$
  - 因此总体的数学期望为：$[0+1+...+(n-1)]/2+1=o(n^2)$

**PS：逆序对** ：

- 从逆序对的角度看，逆序对的数量都记在逆序对后一个元素。
- 插入排序一般度量表示为$o(I+n),\quad I=\sum i(p), \quad i(p)为逆序对数量\quad n为插入开销$。
- 可以解读为一次次修复列表的无序，所以复杂度取决于输入的无序程度，为**输入敏感的的排序**。





