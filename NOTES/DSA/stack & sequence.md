# 栈结构

只能访问栈顶。可以通过向量和列表进行派生。eg：向量派生，沿用`size`和`empty`接口，从性能上可以将数组末尾作为栈顶。

## 栈应用

### 逆序输出——进制转换

输出次序和处理过程颠到，递归深度和输出不易预知

### 递归嵌套——括号匹配

具有自相似性的问题，分支位置和深度不易预知。

如果采用计数器是不行的因为会遇到`[ ( ] ) ` 的情况

**栈混洗**



### 延迟缓冲——中缀表达式求值

线性扫描中，在预读足够长之后才能确定可处理的前缀。

<img src=".\img\栈-计算优先级.png" width=600px>



### 逆波兰表达式（RPN）

逆波兰表达式只需要一个栈就能完成运算，将中缀表达式转为逆波兰表达式：

`(0!+1)^(2*3!+4-5) `

1. 显示添加括号表示优先级：`{([0!]+1)^([[2*[3!]]+4]-5)}`
2. 将运算符后移到对应右括号的右侧：`{([0]!1)+([[2[3]!]*4]+5)-}^ `
3. 移除所有括号：`0 ! 1 + 2 3 ! * 4 + 5 - ^ `



# 队列

只能在队尾插入，在对头删除，用列表可以很好的实现。

<img src=".\img\队列-链表实现.png" width=600px>