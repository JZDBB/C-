# Q&A

## 左值 & 右值

**左值 (lvalue, locator value)** 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。

**右值 (rvalue)** 非左值即右值；是一个 不 表示内存中某个可识别位置的对象的表达式。

```C++
var = 2 // var为左值，2为右值
    
int foo() {return 2;}
int main(){
    foo() = 2; // 错误，foo是确定的返回一个右值，不能作为左值使用
    return 0;
}
int& foo(){
    return 2; // 错误，foo是返回引用，是左值，不应该返回右值
}
```



## 构造函数

### 深层&浅层

- 深层复制：对象类型为指针类型时，复制指针所指对象，重新构造对应对象分配相应内存（防止析构出错）

- 浅层复制：对应元素一一复制

<img src="img/深层复制构造.png" height=250px>

### 移动构造

- 函数返回含有指针成员的对象
  - 深层复制构造，动态分配临时对象，返回主调函数是要删除临时对象
  - 移动构造：将返回的局部对象转移到主调函数，省掉构造和删除临时对象。

移动构造效率高一些



## 迭代器





## 程序运行

一个编译单元（translation unit）是指一个.cpp文件以及它所#include的所有.h文件，.h文件里的代码将会被扩展到**包含它的.cpp文件**里，然后编译器编译该.cpp文件为一个.obj文件（假定我们的平台是win32）。后者拥有PE（Portable Executable，即windows可执行文件）文件格式，并且本身包含的就已经是二进制码，但是不一定能够执行，因为并不保证其中一定有main函数。当编译器将一个工程里的所有.cpp文件以分离的方式编译完毕后，再由连接器（linker）进行连接成为一个.exe文件。

而在其他包含.h文件的cpp文件中定义的函数实际上在连接过程中再去通过连接符号到相应地址调用函数。

1. 编译main.cpp时，编译器不知道f的实现，所以当碰到对它的调用时只是给出一个指示，指示连接器应该为它寻找f的实现体。这也就是说main.obj中没有关于f的任何一行二进制代码。
2. 编译test.cpp时，编译器找到了f的实现。于是乎f的实现（二进制代码）出现在test.obj里。
3. 连接时，连接器在test.obj中找到f的实现代码（二进制）的地址（通过符号导出表）。然后将main.obj中悬而未决的call XXX地址改成f实际的地址。完成。

然而，对于模板，你知道，模板函数的代码其实并不能直接编译成二进制代码，其中要有一个“实例化”的过程。

C++标准表示，当一个模板不被用到的时侯它就不该被实例化出来，在对应的cpp文件中没有用到了`A<int>::f`，所以实际上test.cpp编译出来的test.obj文件中关于A::f一行二进制代码也没有，这是一个连接错误。但是，如果在test.cpp中写一个函数，其中调用`A<int>::f`，则编译器会将其实例化出来，因为在这个点上（test.cpp中），编译器知道模板的定义，所以能够实例化，于是，test.obj的符号导出表中就有了`A<int>::f`这个符号的地址，于是连接器就能够完成任务。

关键是：在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。



## 求中点

二分查找中我们需要根据 `start` 和 `end` 求中点，正常情况下加起来除以 2 即可。

`int mid = (start + end) / 2`
但这样有一个缺点，我们知道`int`的最大值是 `Integer.MAX_VALUE` ，也就是`2147483647`。那么有一个问题，如果 `start = 2147483645，end = = 2147483645`，虽然 `start` 和 `end`都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致`mid`计算错误。

解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形。

```C++
(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2
```

更好的，求mid的方法如下：

```c++
int mid = (start + end) >>> 1
```

首先大家可以补一下 补码 的知识。

其实问题的关键就是这里了>>> ，我们知道还有一种右移是>>。区别在于>>为有符号右移，右移以后最高位保持原来的最高位。而>>>这个右移的话最高位补 0。

所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end 溢出的时候，其实本质上只是符号位收到了进位，而>>>这个右移不仅可以把符号位右移，同时最高位只是补零，不会对数字的大小造成影响。

但>>有符号右移就会出现问题了，事实上 JDK6 之前都用的>>，这个 BUG 在 java 里竟然隐藏了十年之久。







## 解决问题的思路

几种思想+几种数据结构特点。

#### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

难度中等171

给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

**进阶：**

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

```
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
```

*不能翻转，正好是反过来的，那么就可以考虑先进后出的栈*

