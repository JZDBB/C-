# C++

## 基础

### 指针和引用的区别

> **指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，实质上和原变量相同。**
>
> - 引用不可以为空，但指针可以为空。
> - 引用不可以改变指向，但是指针可以改变指向，而指向其它对象。
> - 引用比指针更安全。

### 代码内存分布

> 对于一个完整的程序，在内存中的分布情况如下：
>
> 1.**代码区**
> 2.**全局数据区**: 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。
> 3.**堆区**: 程序员分配并释放的区域，像malloc(c),new(c++)
> 4.**栈区**: 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
>
> 一般程序的由`new`产生的动态数据存放在堆区，函数内部的`自动变量`存放在栈区。自动变量一般会随着函数的退出而释放空间，`静态数据`（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。

### 内存模型

> C分为四个区：堆，栈，静态全局变量区，常量区
>
> C++内存分为5个区域（**堆、栈、全、常、代**）：
>
> - 堆 heap ：
>   由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”
> - 栈 stack ：
>   是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
>   存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。
> - 全局/静态存储区 （.bss段和.data段） ：
>   全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。
> - 常量存储区 （.rodata段） ：
>   存放常量(包括字符串常量)，不允许修改（通过非正当手段也可以修改）
> - 代码区 （.text段） ：
>   存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
>
> 根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即`自由存储区`，`动态区`、`静态区`。
>
> - 自由存储区：局部非静态变量的存储区域，即平常所说的`栈`
> - 动态区： 用operator new ，malloc分配的内存，即平常所说的`堆`
> - 静态区：全局变量 静态变量 字符串常量存在位置

### 堆和栈的区别

> **数据结构**
>
> - 栈：是一种**连续**储存的数据结构，具有**先进后出**的性质。通常的操作有入栈（圧栈）、出栈和栈顶元素。想要读取栈中的某个元素，就要将其之前的所有元素出栈才能完成。类比现实中的箱子一样。
> - 堆：是一种**非连续**的树形储存数据结构，每个节点有一个值，整棵树是**经过排序**的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。
>
> **内存**
>
> - **栈内存**：由程序**自动**向操作系统申请分配以及回收，速度快，方便。通常存放局部变量、函数参数等。
> - **堆内存**：是由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。

### C和C++的区别

> - C是一个结构化语言，面向过程，重点在于算法和数据结构。
> - C++，面向对象，封装性更好。构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 

### 指针数组和数组指针的区别

> 数组指针应该是指向数组的指针，而指针数组则是指该数组的元素均为指针。

### 指针函数和函数指针

> 函数指针：指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么指向这个函数的函数指针便是指向这个地址。函数指针主要有两个作用：用作调用函数和做函数的参数。
> 
>指针函数：是指函数的返回值为指针的函数

### 二维动态数组的申请和删除

> 首先是如何申请二维的数组，这里我们先申请一个指针数组，然后令指针数组中的每一个元素都指向一个数组，这样二维数组就成了：
>
> ```C++
> size_t row, col;
> // 声明空间
> int **MathTable = new int*[row];
> for (int i = 0; i < row; i++)
> MathTable[i] = new int[col];
> // 释放空间
> for (int i = 0; i < row; i++)
>     delete[] MathTable[i];
> delete[]MathTable;
> ```

### 如何处理循环引用问题

> 有两个或者以上的对象，它们彼此引用，就会造成循环引用。
>
> ```C++
> class Node { 
>     Node next ;
> } 
> Node a = new Node (); 
> Node b = new Node (); 
> a . next = b ; 
> b . next = a ;
> ```
>
> 

### 内存泄漏的情况

> 

## 关键字

### sizeof

> 如果是**数组首地址**，sizeof会输出**数组所占地址空间的大小**（字节为单位）。
> 如果是一个**指针**的话，则输出在该系统中**地址的字节宽度**，即（位宽/8）。
> 如果是通过**函数传递过来的地址**，那么sizeof会把数组首地址和指针**无差别当成是地址**。
> 注意如果是**字符串**，则末尾还有系统默认添加的`\n`。
>
> `char`，`float`，`short`，`double`，`long long`这几个的长度不会因为编译环境而改变，只和系统相关，**long**和**指针**的大小则会是**系统位宽/8**。`int`一般都是32位(4个字节)。
>
> | 数据类型       | 32位 | 64位 | 取值范围                 |
> | -------------- | ---- | ---- | ------------------------ |
> | char           | 1    | 1    | -128~127                 |
> | unsigned char  | 1    | 1    | 0~255                    |
> | short          | 2    | 2    | –2^15^~2^15^-1           |
> | int            | 4    | 4    | -2^31^~2^31^-1           |
> | unsigned int   | 4    | 4    | 0~2^32^-1                |
> | long int /long | 4    | 8    | -2^31^~2^31^-1           |
> | long long      | 8    | 8    | -2^63^~2^63^-1           |
> | 指针           | 4    | 8    |                          |
> | float          | 4    | 4    | 3.4E +/- 38 (7 digits)   |
> | double         | 8    | 8    | 1.7E +/- 308 (15 digits) |
>

### C++的内存对齐

> 各成员变量存放的起始地址**相对于**`class`或`struct`的**起始地址的偏移量**必须为该变量的类型所占用的字节数的倍数。变量在类中的起始位置必须是本类型的大小的整数倍。编译器默认会对结构体进行处理，让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，整个结构体的sizeof值就增长了。
>
> 字节对齐的细节一般而言，满足三个准则：
>
> - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。
> - 结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节（internal adding）。
> - 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员后加上填充字节（trailing padding）。
>
> 注意：**空结构体（不含数据成员）的sizeof值为1**。“空结构体”变量也得被存储，编译器会为其分配一个字节的空间用于占位。

### Const

> const参与编译运行，拥有类型，会执行相应的类型检查，会占用内存，const内存效率更高，编译器通常将const变量保存在符号表中，不会分配存储空间，使它成为一个编译期间的常量。关键字`const`出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。声明迭代器为`const`就像声明指针为`const`一样。
>
> 在正常情况下，在`const`成员函数内是无法改变私有变量的值，因此，为了改变成员变量，在成员变量前加上mutabke(可变的)
>
> 修饰成员函数，表示该成员函数不会修改成员变量
>
> ```C++
> const int* ptr; // 指向const变量的指针——常量指针
> int const* ptr; // 指向const变量的指针,指针所指向的对象是const的，不能使用指针修改
> int* const ptr; // const指针，即指针本身是const的，不能指向其他地址——指针常量
> ```

### 强制类型转换

> - **const_cast**：通常被用来将对象的常量性转除，移除`const`动作
> - **static_cast**：用来强迫隐式转换，如：将`non-const`对象转换为`const`对象，将int转换为double等。
> - **reinterpret_cast**：转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型,反之亦然。 这个操作符能够在非相关的类型之间转换。
> - **dynamic_cast**：只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。dynamic_cast 会检查操作是否有效。它会检查转换是否会返回一个有效的完整对象。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL。对于引用类型，会抛出bad_cast异常

### define

> define只是字符串替换，不参与编译运行，define仅仅是宏替换，不占⽤用内存，不做类型检查
>
> 应尽量减少`#define`的使用，即宁可以编译器替换预处理器。
>
> 对于单纯常量，最好以const对象或enums替换#define。
>
> 对于形似函数的宏，最好改用inline函数替换#define。

### typeof

> 将一种数据类型定义为某一个标识符，在程序中使用该标识符来实现相应数据类型变量的定义。	
>
> `typedef int INT;`则INT表示整型
> `typedef int* INTPTR;`则INTPTR是一个指向整型变量的指针类型
>
> ```C++
> // 定义结构体类型
> typedef struct {int x; int y;} Point;  
> // 定义数组类型
> typedef int MyIntArray [100]; 
> MyIntArray ia;  // 相当于：int ia[100];
> // 定义函数指针
> typedef void (*FUNCADDR)(int)   // 此处FUNCADDR是指向这样一个函数的指针，该函数的返回值为void类型，函数有一个int型的参数。
> // 定义类类型
> typedef class {  
>     private:  int a;  
>     public:  int b;  
> } MyClass;
> ```

### inline

> 将代码进行复制，扩充，会使代码总量上升，好处就是可以节省调用的开销，能提高执行效率。
>
> define只是字符串替换，inline由编译器控制，具体的：
> • define只是简单的宏替换，通常会产生二义性；而inline会真正地编译到代码中
> • inline函数是否展开由编译器决定，有时候当函数太大时，编译器可能选择不展开相应的函数
>
> virtual函数拒绝inline

### static

> ##### 一、面向过程设计中的static
>
> **静态全局变量**
>
> - 静态全局变量特点
>   - 在全局数据区分配内存；
>   - 未经初始化的静态全局变量会被程序自动初始化为0；
>   - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；　
>   - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。
>   - 静态全局变量不被其它文件所用(extern也不行)；其它文件中可以定义相同名字的变量，不冲突；
>
> **静态局部变量**
>
> - 静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。
> - 静态局部变量特点
>   - 该变量在全局数据区分配内存(局部变量在栈区分配内存);
>   - 在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化)；
>   - 静态局部变量一般在声明处初始化，若没有初始化会被程序自动初始化为0(局部变量不会被初始化);
>   - 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);
>
> **静态函数**
>
> 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。静态函数的优点与静态全局变量的优点一样的
>
> ##### 二、面向对象的static关键字（类中的static关键字）
>
> **静态数据成员**
>
> ```C++
> class Myclass  
> {  
> private:  
>     int a , b , c;  
>     static int sum;  //声明静态数据成员  
> public:  
>     Myclass(int a , int b , int c);  
>     void GetSum();  
> };  
> int Myclass::sum = 0;   //定义并初始化静态数据成员  
> ```
>
> - 在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
> - **在类内只能声明，然后在类外定义，如果static const则不用**
> - 静态数据成员特点
>
>    - 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问。对该类的多个对象来说，**静态数据成员只分配一次内存，供所有对象共用。**
>
>    - 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
>
>    - 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
>      **＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞**
>      类的静态数据成员有两种访问形式：
>      **＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞**
>      
>      如果静态数据成员的访问权限允许的话（public），在程序中按上述格式来引用静态数据成员 ；
>
>   - 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类的利息。优势在于节省存储空间和方便随时调整改变。
>   - 同全局变量相比，使用静态数据成员有两个优势：
>       1.静态数据成员没有进入程序的全局名字空间，因此**不存在与程序中其它全局名字冲突**的可能性；
>       2.可以实现**信息隐藏**。静态数据成员可以是private成员，而全局变量不能；
>
> **静态成员函数**
>
> 静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。`静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分`。普通的成员 函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，`因此它不具有this指针`。从这个意义上讲，它**无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数**，它只能调用其余的静态成员函数。
>
> 静态成员函数特点
>
> - 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
> - 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
> - 静态成员函数不能访问非静态成员函数和非静态数据成员；
> - 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
> - 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
>   **＜类名＞::＜静态成员函数名＞（＜参数表＞）**
>

### new和delete是如何实现的，new 与 malloc的异同处

> - **new** 
>   - 简单类型（指**基本数据类型**和**不需要构造函数**的类型）直接调用operator new分配内存。
>   - 复杂数据类型的时候先调用operator new，**然后在分配的内存上调用构造函数**
>   - 通过new_handler来处理new失败的情况，new分配失败的时候会直接抛出异常。要判断是否分配成功应该用异常捕获的机制
> - **new []**
>   - 针对简单类型，new[] 调用的是operator new[]，计算出数组总大小之后调用operator new。
>   - 复杂类型，new[]先调用operator new[]根据数组大小分配内存，在开始位置的**前面多分配四个字节**，用来存储数组的大小，后面delete[]要用到。最后调用数组大小次数的构造函数
> - **delete**
>   - delete简单数据类型调用operator delete，其内部默认只是调用free函数。
>   - delete 复杂数据类型**先调用析构函数**，再调用operator delete。
> - **delete []**
>   - 简单数据类型，和delete相同
>   - 复杂数据类型：释放内存之前会先调用每个对象的析构函数。new[]分配的内存**只能由** delete[]释放。调用析构函数的次数是从数组对象指针前面的 4 个字节中取出。
>   - 如果由delete释放会崩溃，直接释放指向的内存空间，会造成严重的段错误，程序必然会奔溃！因为分配的空间的起始地址是指针指向的地方减去 4 个字节的地方
>
> 使用 `new []` 用 delete 来释放对象的提前是：对象的类型是内置类型或者是无自定义的析构函数的类类型！

### new & new[] 、delete & delete[]

> - delete 复杂数据类型**先调用析构函数**，再调用operator delete。
>
> **delete[]过程**
>
> - 释放内存之前会先调用每个对象的析构函数。
> - new[]分配的内存**只能由** delete[]释放。
> - 如果由delete释放会崩溃，为什么会崩溃呢？
>   - 假设指针`p`指向new[]分配的内存。因为要**4字节存储数组大小**，实际分配的内存地址**起始为[p-4]**，系统记录的也是这个地址。`delete[]`实际释放的就是`p-4`指向的内存。而`delete`会直接释放`p`指向的内存，这个内存根本**没有被系统记录**，所以会崩溃。
>



## Class

###  C++ 的面向对象特性（封装、继承、多态）

> - 封装：使用函数指针把属性与方法封装到结构体中
> - 继承：结构体嵌套
> - 多态：父类与子类方法的函数指针不同
>
> **封装**
>
> 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。
>
> - `public` 成员：可以被任意实体访问
> - `protected` 成员：只允许被子类及本类的成员函数访问
> - `private` 成员：只允许被本类的成员函数、友元类或友元函数访问
>
> **继承**
>
> - 基类（父类）——> 派生类（子类）
>
> **多态**
>
> - 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。
> - 多态是以封装和继承为基础的。
> - C++ 多态分类及实现：
>   1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
>   2. 子类型多态（Subtype Polymorphism，运行期）：虚函数
>   3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
>   4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

### c++虚函数和纯虚函数原理

> - 类里声明的虚函数，这个函数是实现的，是为了能让函数在它的子类里面可以被覆盖，这样就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。、
> - 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。通常把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性。
> - 虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。
> - 带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。

### c++多态实现

> 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。
>
> 1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
>
> 2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  
>
> 3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  
>
> 4：多态用虚函数来实现，结合动态绑定.  
>
> 5：纯虚函数是虚函数再加上 = 0；  
>
> 6：抽象类是指包括至少一个纯虚函数的类。
>
>  实现主要是以下三步
>
> - 父类的函数为虚函数(函数前加上virtual关键字)
> - 子类重写父类的虚函数(不必须加virtual)
> - 父类的指针或引用指向子类对象

### 虚函数例子

> ```C++
> class Base{
> public:
>     virtual void Print() const{
>         cout << "Print in Base" << endl;
>     }
> };
> class Derive::public base{
> public:
>     void Print() const{
>         cout << "Print in Derive" << endl;
>     }
> };
> void Print(const Base* base){
>     base->Print();
> }
> int main(){
>     Base b;
>     Derive d;
>     print(&b);
>     print(&d);
>     return 0;
> } // 结果为：Print in Base, Print in Derive
> // 删除virtual结果为：Print in Base, Print in Base
> ```

### 虚函数表、vptr

> 虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应不同基类的虚函数表。
>
> - 每个**空类**占用一个字节，而有了虚函数的类A则占用了四个字节，因为一旦类中有了虚函数，编译器会为这个类生成一个**虚函数表**，最重要的是编译器会给包含虚函数的类加上一个成员变量，一个指向**虚函数表**的指针(`vptr`)。**虚表**是属于类的，而**虚表指针**是从属于对象的。也就是说，如果一个类含有虚表，则该类的所有对象都会含有一个虚表指针，并且该虚表指针**指向同一个虚表**。
> - 虚表是一个**指针数组**，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
> - 虚表的内容，即虚函数指针的赋值发生在**编译器的编译阶段**，也就是说在代码的编译阶段，虚表就可以构造出来了。
>
> 访问普通成员函数更快，因为普通成员函数的地址在编译阶段就已确定，因此在访问时直接调用对应地址的函数，而虚函数在调用需要在虚函数表中寻找虚函数所在地址，因此相比普通成员函数速度要慢一些。

### 内联函数、构造函数、静态成员函数可以是虚函数么

> 都不可以。
>
> 1.内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；
>
> 2.构造函数在调用时不存在父类和子类的概念，父类调用父类的构造函数，子类调用子类，不存在动态绑定；
>
> 3.静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，两个不冲突；

### 怎么理解重载与重写

> **重载**是指在同一作用域中允许有多个同名函数，而这些函数的参数列表不同，包括参数个数，类型，次序不同，需要注意的是**返回值并不影响**是否重载。
> 而**重写**（覆盖）和**重定义**（同名隐藏）则有点像，区别就是在于重写的函数是否是虚函数。
> 如果父类的函数是虚函数，则为重写，从而实现多态。如果是普通成员函数，则为重定义，如果子类没有重定义，则调用时仍旧调用父类的，否则调用子类的。

### 动态绑定和静态绑定的区别

> (1)对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
> (2)对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
> (3)静态绑定：绑定的是对象的静态类型，某特性(比如函数)依赖于对象的静态类型，发生在编译期。
> (4)动态绑定：绑定的是对象的动态类型，某特性(比如函数)依赖于对象的动态类型，发生在运行期。

### 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？

> a、一个对象以值传递的方式传入函数体
> b、一个对象以值传递的方式从函数返回
> c、一个对象需要通过另外一个对象进行初始化
>
> 类中的数据成员需要动态分配存储空间时，不可以依赖default copy constructor。当default copy constructor被因编译器需要而合成时，将执行default memberwise copy语义。

### 深拷贝和浅拷贝的区别

> **浅拷贝**：如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。即称为浅拷贝。
> **深拷贝**：然而在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。

### 基类为什么需要虚析构函数？

> 当派生类经由一个基类指针被删除而该基类的析构函数为非虚函数时，将发生未定义行为。导致资源泄漏。
> 解决方法即为：为多态基类声明一个virtual 析构函数。



## STL

### STL中的vector怎么扩容

> Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，按照一定的倍数分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。

### vector的reserve和capacity的区别?

> reserve()用于让容器预留空间，避免再次内存分配；capacity() 返回在重新内存分配以前的容量。

### 相等和等价的区别

> 相等(equality)是以`operator==`为基础，如果`x == y`为真，则判定x和y相等。
> 等价(equavalence)是以`operator<`为基础，如果`!(x < y) && !(y < x)`为真，则判定x和y等价。
> 通常，关联容器采用“等价”，而顺序容器采用“相等”。

### STL中排序算法的实现是什么

> STL中的sort()，在数据量大时，采用quicksort，分段递归排序；一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort。



## 版本问题

### 用过C++ 11吗，知道C++ 11哪些新特性？

- **自动类型推断**auto
- lambda表达式
- 新的指针常量`nullptr`
- 智能指针：智能指针是一个`RAII`（`Resource Acquisition is initialization`）类模型，用来动态的分配内存。它提供所有普通指针提供的接口，却很少发生异常。在构造中，它分配内存，当离开作用域时，它会自动释放已分配的内存。这样的话，程序员就从手动管理动态内存的繁杂任务中解放出来了。
- `thread`支持多线程操作

### 请简述智能指针原理，并实现一个简单的智能指针。















##  auto_ptr能作为vector的元素吗？为什么？

答：不可以。
当复制一个auto_ptr时，它所指向的对象的所有权被交到复制的auto_ptr上面，而它自身将被设置为null。复制一个auto_ptr意味着改变它的值。





虚函数指针的初始化过程
vector和list 的区别
c++的内存分配
map与set的底层实现



#### struct和class的区别

> 总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
>
> **区别**
>
> - 最本质的一个区别就是默认的访问控制
>   1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。
>   2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。





#### 拷贝初始化和直接初始化，初始化和赋值的区别





#### public，protected和private访问权限和继承













# 操作系统

### 进程与线程的区别

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

