# C++

## 基础

### 指针和引用的区别

> **指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，实质上和原变量相同。**
>
> - 引用不可以为空，但指针可以为空。
> - 引用不可以改变指向，但是指针可以改变指向，而指向其它对象。
> - 引用比指针更安全。

### 代码内存分布

> 对于一个完整的程序，在内存中的分布情况如下：
>
> 1.**代码区**
> 2.**全局数据区**: 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。
> 3.**堆区**: 程序员分配并释放的区域，像malloc(c),new(c++)
> 4.**栈区**: 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
>
> 一般程序的由`new`产生的动态数据存放在堆区，函数内部的`自动变量`存放在栈区。自动变量一般会随着函数的退出而释放空间，`静态数据`（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。

### 内存模型

> C分为四个区：堆，栈，静态全局变量区，常量区
>
> C++内存分为5个区域（**堆、栈、全、常、代**）：
>
> - 堆 heap ：
>   由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”
> - 栈 stack ：
>   是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
>   存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。
> - 全局/静态存储区 （.bss段和.data段） ：
>   全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。
> - 常量存储区 （.rodata段） ：
>   存放常量(包括字符串常量)，不允许修改（通过非正当手段也可以修改）
> - 代码区 （.text段） ：
>   存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
>
> 根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即`自由存储区`，`动态区`、`静态区`。
>
> - 自由存储区：局部非静态变量的存储区域，即平常所说的`栈`
> - 动态区： 用operator new ，malloc分配的内存，即平常所说的`堆`
> - 静态区：全局变量 静态变量 字符串常量存在位置

### 堆和栈的区别

> **数据结构**
>
> - 栈：是一种**连续**储存的数据结构，具有**先进后出**的性质。通常的操作有入栈（圧栈）、出栈和栈顶元素。想要读取栈中的某个元素，就要将其之前的所有元素出栈才能完成。类比现实中的箱子一样。
> - 堆：是一种**非连续**的树形储存数据结构，每个节点有一个值，整棵树是**经过排序**的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。
>
> **内存**
>
> - **栈内存**：由程序**自动**向操作系统申请分配以及回收，速度快，方便。通常存放局部变量、函数参数等。
> - **堆内存**：是由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。

### C和C++的区别

> - C是一个结构化语言，面向过程，重点在于算法和数据结构。
> - C++，面向对象，封装性更好。构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 

### 指针数组和数组指针的区别

> 数组指针应该是指向数组的指针，而指针数组则是指该数组的元素均为指针。

### 指针函数和函数指针

> 函数指针：指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么指向这个函数的函数指针便是指向这个地址。函数指针主要有两个作用：用作调用函数和做函数的参数。
> 
>指针函数：是指函数的返回值为指针的函数

### 二维动态数组的申请和删除

> 首先是如何申请二维的数组，这里我们先申请一个指针数组，然后令指针数组中的每一个元素都指向一个数组，这样二维数组就成了：
>
> ```C++
> size_t row, col;
> // 声明空间
> int **MathTable = new int*[row];
> for (int i = 0; i < row; i++)
> MathTable[i] = new int[col];
> // 释放空间
> for (int i = 0; i < row; i++)
>     delete[] MathTable[i];
> delete[]MathTable;
> ```





## 关键字

### sizeof

> 对于直接的调用sizeof，如果是**数组首地址**，sizeof会输出**数组所占地址空间的大小**（字节为单位)。如果是一个**指针**的话，则输出在该系统中**地址的字节宽度**，即（位宽/8)。
>   如果是通过**函数传递过来的地址**，那么sizeof会把数组首地址和指针**无差别当成是地址**。
>   注意如果是**字符串**，则末尾还有系统默认添加的`\n`。

### C++的内存对齐

> 所有的空间均需要为最大类型大小的整数倍

### Const





### static

##### 一、面向过程设计中的static

**静态全局变量**

- 在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量
- 静态全局变量特点
  - 在全局数据区分配内存；
  - 未经初始化的静态全局变量会被程序自动初始化为0；
  - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；　
  - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。
  - 静态全局变量不能被其它文件所用(extern也不行)；
  - 其它文件中可以定义相同名字的变量，不会发生冲突；

**静态局部变量**

- 在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。
- 静态局部变量特点
  - 该变量在全局数据区分配内存(局部变量在栈区分配内存);
  - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化)；
  - 静态局部变量一般在声明处初始化，若没有显式初始化会被程序自动初始化为0(局部变量不会被初始化);
  - 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);

**静态函数**

  在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。静态函数的优点与静态全局变量的优点一样的

##### 二、面向对象的static关键字（类中的static关键字）

**静态数据成员**

```C++
class Myclass  
{  
private:  
    int a , b , c;  
    static int sum;  //声明静态数据成员  
public:  
    Myclass(int a , int b , int c);  
    void GetSum();  
};  
int Myclass::sum = 0;   //定义并初始化静态数据成员  
```

- 在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
- **在类内只能声明，然后在类外定义，如果static const则不用**
- 静态数据成员特点

   - 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，**静态数据成员只分配一次内存，供所有对象共用。**所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；

   - 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。静态数据成员和普通数据成员一样遵从public,protected,private访问规则；因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；

   - 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
     **＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞**
     类的静态数据成员有两种访问形式：
     **＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞**
     
     如果静态数据成员的访问权限允许的话（即public的成员），在程序中按上述格式来引用静态数据成员 ；

  - 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；
  - 同全局变量相比，使用静态数据成员有两个优势：
      1.静态数据成员没有进入程序的全局名字空间，因此**不存在与程序中其它全局名字冲突**的可能性；
      2.可以实现**信息隐藏**。静态数据成员可以是private成员，而全局变量不能；

**静态成员函数**

静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。`静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分`。普通的成员 函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，`因此它不具有this指针`。从这个意义上讲，它**无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数**，它只能调用其余的静态成员函数。

静态成员函数特点

- 出现在类体外的函数定义不能指定关键字static；
- 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
- 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
- 静态成员函数不能访问非静态成员函数和非静态数据成员；
- 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
- 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
  **＜类名＞::＜静态成员函数名＞（＜参数表＞）**
  调用类的静态成员函数。



### new和delete是如何实现的，new 与 malloc的异同处

> **相同点：**
>
> 都用来申明一块空间供我们使用；malloc与new必须要与free和delete配对使用，否则会造成内存泄漏。
>
> **不同点：**
>
> - malloc与free是标准C库函数，而new与delete是C++里面的运算符；
> - new是用来创造对象的，先申请内存，然后使用类的构造函数来初始化对象，在调用delete时也一样是先调用析构函数，然后再释放内存空间，而malloc是直接开辟出一块空间，并不会为对象初始化；
> - malloc申请空间后返回的是一个void*类型的指针，我们要在使用时将其强转为我们要使用的类型，而new返回的是我们所创建对象类型的指针。
> - malloc申请空间时无法对数据初始化，而new会调用构造函数初始化。

### delete & delete[]

- delete 复杂数据类型**先调用析构函数**，再调用operator delete。

**delete[]过程**

- 释放内存之前会先调用每个对象的析构函数。
- new[]分配的内存**只能由** delete[]释放。
- 如果由delete释放会崩溃，为什么会崩溃呢？
  - 假设指针`p`指向new[]分配的内存。因为要**4字节存储数组大小**，实际分配的内存地址**起始为[p-4]**，系统记录的也是这个地址。`delete[]`实际释放的就是`p-4`指向的内存。而`delete`会直接释放`p`指向的内存，这个内存根本**没有被系统记录**，所以会崩溃。



## Class

###  C++ 的面向对象特性（封装、继承、多态）

> - 封装：使用函数指针把属性与方法封装到结构体中
> - 继承：结构体嵌套
> - 多态：父类与子类方法的函数指针不同
>
> **封装**
>
> 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。
>
> - `public` 成员：可以被任意实体访问
> - `protected` 成员：只允许被子类及本类的成员函数访问
> - `private` 成员：只允许被本类的成员函数、友元类或友元函数访问
>
> **继承**
>
> - 基类（父类）——> 派生类（子类）
>
> **多态**
>
> - 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。
> - 多态是以封装和继承为基础的。
> - C++ 多态分类及实现：
>   1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
>   2. 子类型多态（Subtype Polymorphism，运行期）：虚函数
>   3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
>   4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

### c++虚函数和纯虚函数原理

> - 类里声明的虚函数，这个函数是实现的，是为了能让函数在它的子类里面可以被覆盖，这样就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。、
> - 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。通常把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性。
> - 虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。
> - 带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。

### c++多态实现

> 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。
>
> 1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
>
> 2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  
>
> 3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  
>
> 4：多态用虚函数来实现，结合动态绑定.  
>
> 5：纯虚函数是虚函数再加上 = 0；  
>
> 6：抽象类是指包括至少一个纯虚函数的类。
>
>  实现主要是以下三步
>
> - 父类的函数为虚函数(函数前加上virtual关键字)
> - 子类重写父类的虚函数(不必须加virtual)
> - 父类的指针或引用指向子类对象

### 虚函数表、vptr

> - 每个**空类**占用一个字节，而有了虚函数的类A则占用了四个字节，因为一旦类中有了虚函数，编译器会为这个类生成一个**虚函数表**，最重要的是编译器会给包含虚函数的类加上一个成员变量，一个指向**虚函数表**的指针(`vptr`)。**虚表**是属于类的，而**虚表指针**是从属于对象的。也就是说，如果一个类含有虚表，则该类的所有对象都会含有一个虚表指针，并且该虚表指针**指向同一个虚表**。
> - 虚表是一个**指针数组**，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
> - 虚表的内容，即虚函数指针的赋值发生在**编译器的编译阶段**，也就是说在代码的编译阶段，虚表就可以构造出来了。

### 怎么理解重载与重写

> **重载**是指在同一作用域中允许有多个同名函数，而这些函数的参数列表不同，包括参数个数，类型，次序不同，需要注意的是**返回值并不影响**是否重载。
> 而**重写**（覆盖）和**重定义**（同名隐藏）则有点像，区别就是在于重写的函数是否是虚函数。
> 如果父类的函数是虚函数，则为重写，从而实现多态。如果是普通成员函数，则为重定义，如果子类没有重定义，则调用时仍旧调用父类的，否则调用子类的。

### 动态绑定和静态绑定的区别

> (1)对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
> (2)对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
> (3)静态绑定：绑定的是对象的静态类型，某特性(比如函数)依赖于对象的静态类型，发生在编译期。
> (4)动态绑定：绑定的是对象的动态类型，某特性(比如函数)依赖于对象的动态类型，发生在运行期。

### 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？

> a、一个对象以值传递的方式传入函数体
> b、一个对象以值传递的方式从函数返回
> c、一个对象需要通过另外一个对象进行初始化
>
> 类中的数据成员需要动态分配存储空间时，不可以依赖default copy constructor。当default copy constructor被因编译器需要而合成时，将执行default memberwise copy语义。

### 深拷贝和浅拷贝的区别

> **浅拷贝**：如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。即称为浅拷贝。
> **深拷贝**：然而在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。

### 基类为什么需要虚析构函数？

> 当派生类经由一个基类指针被删除而该基类的析构函数为非虚函数时，将发生未定义行为。导致资源泄漏。
> 解决方法即为：为多态基类声明一个virtual 析构函数。



## STL

### STL中的vector怎么扩容

> Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，按照一定的倍数分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。

### vector的reserve和capacity的区别?

> reserve()用于让容器预留空间，避免再次内存分配；capacity() 返回在重新内存分配以前的容量。

### 相等和等价的区别

> 相等(equality)是以`operator==`为基础，如果`x == y`为真，则判定x和y相等。
> 等价(equavalence)是以`operator<`为基础，如果`!(x < y) && !(y < x)`为真，则判定x和y等价。
> 通常，关联容器采用“等价”，而顺序容器采用“相等”。

### STL中排序算法的实现是什么

> STL中的sort()，在数据量大时，采用quicksort，分段递归排序；一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort。

## 版本问题

### 用过C++ 11吗，知道C++ 11哪些新特性？

- **自动类型推断**auto
- lambda表达式
- 新的指针常量`nullptr`
- 智能指针：智能指针是一个`RAII`（`Resource Acquisition is initialization`）类模型，用来动态的分配内存。它提供所有普通指针提供的接口，却很少发生异常。在构造中，它分配内存，当离开作用域时，它会自动释放已分配的内存。这样的话，程序员就从手动管理动态内存的繁杂任务中解放出来了。
- `thread`支持多线程操作

















##  auto_ptr能作为vector的元素吗？为什么？

答：不可以。
当复制一个auto_ptr时，它所指向的对象的所有权被交到复制的auto_ptr上面，而它自身将被设置为null。复制一个auto_ptr意味着改变它的值。





虚函数指针的初始化过程
vector和list 的区别
c++的内存分配
map与set的底层实现
指针常量，常量指针的区别



#### struct和class的区别

> 总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
>
> **区别**
>
> - 最本质的一个区别就是默认的访问控制
>   1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。
>   2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

#### 在C++中const和static的用法（定义，用途）



#### 拷贝初始化和直接初始化，初始化和赋值的区别





#### public，protected和private访问权限和继承













# 操作系统

### 进程与线程的区别

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”



作者：biaodianfu
链接：https://www.zhihu.com/question/25532384/answer/411179772
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。