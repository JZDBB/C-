# 函数

## 内联函数

关键字 inline ——节省参数传递控制开销

- 不能有循环和switch
- 定义必须在其第一次调用之前

**内联是以代码膨胀（复制）为代价**，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，**每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间**。 

## constexpr函数

只允许一条return语句
```C++
constexpr int get_size() { return 20; }
constexpr int foo = get_size();
cout << foo << endl;
```

## 带默认参数

通用方便的特点

默认的参数形参必须在形参列表最右，调用实参和形参结合次序从左到右。

```C++
int add(int x, int y=5, int z=6)
```



## 重载

### 运算符重载

几乎可以重载全部运算符，不能重载的：`.`、`.*`、`::`、`?:` , 重载之后优先级不变。可以重载类内和类外的运算符。运算符重载是一种扩充机制，是一种静态多态。

#### 类内运算符

- 双目运算符

  `函数类型 opterator 运算符(形参){}` 参数个数=原操作数个数$-1$ （后置`++ --` 除外）

- 单目运算符

  - 前置单目：运算符重载为运算对象A的成员函数，无形参
  - 后置单目：运算符重载为对象A的成员函数，具有一个`int` 类型的形参
  

#### 类外运算符

函数形参代表自左向右次序排列的操作数，参数个数等于原操作数个数（后置`++ --` 除外），至少有一个自定义类型的参数。后置单目形参表中要有一个`int` 形参，不需要形参名。如果需要某类的私有成员，可以声明函数为友元。

重载规则：

- 双目运算符`B` ：`operator B (oprd1, oprd2)`
- 前置单目运算符`B` ：`operator B (oprd)`
- 后置单目运算符`B` ：`operator B (oprd, 0)`



