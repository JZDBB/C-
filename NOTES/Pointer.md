# 指针

## 数组

- 定义：`类型说明符 数组名[常量表达式][常量表达式]...` 数组要先定义后使用

- 一维数组

  - 存储，在内存中顺序存放，地址连续的，数组名就是数组首元素的内存地址，不可以被重新赋值
  - 初始化：可以是全部、可以部分、当列出所有值时可以不指定长度

- 二维数组

  - 存储为一维数组的集合，按行存储。
  - 初始化：全部（可以不分组），部分元素初始化（要分组），可以省略第一维下标。
  - 如果不做初始化，非静态数组存在垃圾数据，静态默认全为0
  - 部分初始化没初始化的元素默认为0

### 参数

**数组元素做实参，数组名做参数（形参实参都是数组，事实上传首地址，函数中对数组进行更改会改变数组内容）**

### 对象数组

格式：`类名 数组名[元素个数]`

访问对象数组：`数组名[下标].成员名`

#### demo

`Point a[2]={Point(1,2), Point(3,4)}`

- 如果没有指定显示初始值，数组默认使用默认构造函数。



### 遍历数组

```C++
// 基于指针for循环
int array[3] = {1, 2, 3};
int *p
for(p=array;p<array+sizeof(array)/sizeof(int);++p){
    *p += 2; cout<<*p<<endl;
}
// 基于范围for循环
int array[3] = {1, 2, 3};
for(int & e:array){
    e += 2; cout<<e<<endl;
}
```



## 指针

内存空间——变量名(标识符) / 地址访问(指针) 访问

定义：`数据类型* 指针名 = &变量名`

访问：`*指针名 = 值`

指针运算符`*` 和地址运算符`&`互为逆运算

### 初始化

`存储类型(static..) 数据类型(int...) *指针名 = &变量名(初始地址)`

注意：

-  用变量地址作为初值时，该变量必须在指针初始化之前已声明过，且变量类型应与指针类型一致。
- 可以用一个已有合法值的指针去初始化另一个指针变量。
- 不要用一个内部非静态变量去初始化static 指针。 
- 整数0可以赋值给指针，表示空指针
- 可以定义声明`void`类型指针，表示可以用任何对象指针，但是不能访问

```C++
void *pv;
int i=5; pv=&i;
int *pint = static_cast<int*>(pv);
const int *p1=&a; // a是常量不可改变，但是指针可以改变，（应用到指针防止传参变量被修改）
int b; p1 = &b; // 正确
*p1 = 1;// 错误
int *const p2 = &a; // 指针本身是常量，不能改变，但是地址可以改变
p2 = &b; // 错误
```

### 运算

指针加减——指针指向的地址改为前方或者后方。根据指向对象的类型判断加多少字节。

### 指针参数

需要双向传递，引用传参效率低于指针（指针只需要传首地址）



## 指针分类

### 指针函数

返回为指针的函数。`存储类型 数据类型 *函数名(参数){语句}`

- 不要将函数内非静态局部地址作为函数返回值（因为作用域的关系会被释放——非法地址）
- 在主函数中合法有效才能传递
- 采用`new`分配的可以作为返回，但是要注意`delete`释放，否则会内存泄漏

### 函数指针

定义：`存储类型 数据类型 (*函数指针名)(参数表);` ——> 函数指针指向程序代码存储区起始位置

优势：可以将函数指针作为参数传给函数（函数**回调**）

#### demo

```C++
int compute(int a,int b,int(*func)(int,int)){return func(a,b);}
int max(int a,int b){return ((a>b)?a:b);}
int min(int a,int b){return ((a<b)?a:b);}
int sum(int a,int b){return a+b;}
// main 函数
res = compute(a, b, &max)
```

### 对象指针

定义：`类名 *对象指针名`

访问：`ptr->getX() 或者 (*ptr).getX()`

- this 指针：指向当前对象自己的指针，隐含于每一个非静态成员函数 ，如`return x` = `return this->x`
- 对象指针可以在前向引用中声明使用



## 动态内存分配

动态申请内存：`new 类型名T (初始化参数列表)` （成功分配：T类型指针指向新内存；失败：抛出异常）

释放内存：`delete 指针p` （此处释放必须是`new`出来的指针）

```C++
Point *ptr1 = new Point; //默认构造 或者Point *ptr1 = new Point(1, 2);构造函数
delete ptr1;
```

#### 动态数组

分配：`new 类型名T [数组长度]`

释放：`delete[] 数组名p`  p必须是new分配到的数组首地址

多维数组：

分配：`new 类型名T [第一维长度][第二维长度]...`

eg: `char(*fp)[3];fp = new char[2][3];` 多维数组首地址是指向数组的指针，指针$+1$事实上是指向下一个数组。

```C++
int(*cp)[9][8] = new int[7][9][8];// cp 第一个[9][8]数组的头,这是三位数组
	for (int i = 0; i < 7; i++)
		for (int j = 0; j < 9; j++)
			for (int k = 0; k < 8; k++)
				*(*(*(cp + i) + j) + k) = (i * 100 + j * 10 + k);
```

### 动态数组封装为类

简洁，方便管理









## 数组和指针

定义和赋值：

```C++
int a[10], *pa;
pa = &a[0];// 或者pa = a ——> *pa就是a[0], *(pa+i)=a[i]
```

指针数组：

```c++
int line1[]={1,0,2};
int line2[]={3,1,8};
int line3[]={4,6,9};
int *pLine[3]={line1,line2,line3};
```

指针数组和二维数组的区别：

<img src="\img\Pointer.png" height=250px>

